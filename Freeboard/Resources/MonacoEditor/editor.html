<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<link rel="stylesheet" type="text/css" href="vs/editor/editor.main.css">
<style>
    html, body {
        margin: 0;
        padding: 0;
        width: 100%;
        height: 100%;
        overflow: hidden;
        background: #0a0a0a;
    }
    #editor-container {
        width: 100%;
        height: calc(100% - 22px);
    }
    #status-bar {
        position: fixed;
        bottom: 0;
        left: 0;
        right: 0;
        height: 22px;
        background: #1e1e1e;
        font-family: Menlo, monospace;
        font-size: 11px;
        line-height: 22px;
        padding: 0 8px;
        z-index: 1000;
        border-top: 1px solid #333;
        display: flex;
        justify-content: space-between;
        align-items: center;
    }
    #vim-status {
        color: #d4d4d4;
        flex-shrink: 0;
        flex-grow: 1;
    }
    /* Vim command-line input (created by monaco-vim inside #vim-status > secInfoNode) */
    #vim-status input[type="text"] {
        background: #1e1e1e !important;
        color: #d4d4d4 !important;
        border: none !important;
        outline: none !important;
        font-family: Menlo, monospace !important;
        font-size: 11px !important;
        line-height: 22px !important;
        height: 20px !important;
        width: 200px;
        min-width: 100px;
        max-width: 60%;
        padding: 0 !important;
        margin: 0 2px !important;
        caret-color: #00ff40 !important;
        display: inline-block !important;
        opacity: 1 !important;
        visibility: visible !important;
        position: static !important;
    }
    #editor-hints {
        color: #00c030;
        opacity: 0.5;
        white-space: nowrap;
        flex-shrink: 1;
        min-width: 0;
    }
    #editor-hints .key {
        color: #00ff40;
        opacity: 1;
    }
    /* Clickable hint buttons */
    #editor-hints .hint-action {
        cursor: pointer;
        display: inline;
        border: none;
        background: none;
        padding: 0;
        margin: 0;
        font: inherit;
        color: inherit;
        opacity: inherit;
        line-height: inherit;
        -webkit-user-select: none;
        user-select: none;
    }
    #editor-hints .hint-action:hover {
        opacity: 1;
    }
    #editor-hints .hint-action:hover .key {
        text-decoration: underline;
    }
    /* Clickable vim mode indicator in status bar */
    #vim-status .vim-mode-toggle {
        cursor: pointer;
        -webkit-user-select: none;
        user-select: none;
    }
    #vim-status .vim-mode-toggle:hover {
        text-decoration: underline;
    }
</style>
</head>
<body>
<div id="editor-container"></div>
<div id="status-bar">
    <div id="vim-status"></div>
    <div id="editor-hints"></div>
</div>

<script src="vs/loader.js"></script>
<script src="vs/editor/editor.main.nls.js"></script>
<script src="vs/editor/editor.main.js"></script>
<!-- Load UMD libraries with AMD hidden so they use global assignment path -->
<script>var __define = define; define = undefined;</script>
<script src="monaco-vim.js"></script>
<script src="vscode-textmate.js"></script>
<script src="vscode-oniguruma.js"></script>
<script>define = __define;</script>
<script>
(function() {
    var editor = null;
    var vimEnabled = false;
    var vimModeInstance = null;
    var originalContent = '';
    var focusModeActive = false;
    var statusEl = document.getElementById('vim-status');
    var hintsEl = document.getElementById('editor-hints');
    var editorContainerEl = document.getElementById('editor-container');

    function postMessage(msg) {
        if (window.webkit && window.webkit.messageHandlers && window.webkit.messageHandlers.editorBridge) {
            window.webkit.messageHandlers.editorBridge.postMessage(msg);
        }
    }

    function getVimMode() {
        var statusText = statusEl.textContent || '';
        if (statusText.indexOf('INSERT') !== -1) return 'insert';
        if (statusText.indexOf('REPLACE') !== -1) return 'replace';
        if (statusText.indexOf('VISUAL BLOCK') !== -1) return 'visual-block';
        if (statusText.indexOf('VISUAL LINE') !== -1) return 'visual-line';
        if (statusText.indexOf('VISUAL') !== -1) return 'visual';
        // Command-line mode: monaco-vim renders an input field inside #vim-status
        if (statusEl.querySelector('input[type="text"]')) return 'command';
        return 'normal';
    }

    function isInsertMode() {
        var mode = getVimMode();
        return mode === 'insert' || mode === 'replace';
    }

    function switchToInsertMode() {
        if (!editor || !vimEnabled || getVimMode() === 'insert') return;
        editor.focus();
        // Use the Vim API to send 'i' key to enter insert mode.
        // vimModeInstance is the CodeMirror adapter that Vim.handleKey expects.
        if (vimModeInstance && typeof MonacoVim !== 'undefined') {
            MonacoVim.VimMode.Vim.handleKey(vimModeInstance, 'i');
        }
    }

    function switchToNormalMode() {
        if (!editor || !vimEnabled || getVimMode() === 'normal') return;
        editor.focus();
        if (vimModeInstance && typeof MonacoVim !== 'undefined') {
            MonacoVim.VimMode.Vim.handleKey(vimModeInstance, '<Esc>');
        }
    }

    function updateHints() {
        var focusHint = focusModeActive
            ? '<span class="hint-action" data-action="toggle-focus"><span class="key">\u2318F</span> regular size</span>'
            : '<span class="hint-action" data-action="toggle-focus"><span class="key">\u2318F</span> focus mode</span>';
        if (!vimEnabled) {
            hintsEl.innerHTML = '<span class="hint-action" data-action="save-close"><span class="key">Esc</span> save+close</span>&nbsp;&nbsp;' + focusHint;
            return;
        }
        var mode = getVimMode();
        var saveHint = '<span class="hint-action" data-action="save-close"><span class="key">:x</span> save+close</span>';
        var modeHint;
        switch (mode) {
            case 'insert':
                modeHint = '<span class="hint-action" data-action="normal-mode"><span class="key">jk</span> normal mode</span>';
                break;
            case 'replace':
                modeHint = '<span class="hint-action" data-action="normal-mode"><span class="key">jk</span> normal mode</span>';
                break;
            case 'visual':
            case 'visual-line':
            case 'visual-block':
                modeHint = '<span class="hint-action" data-action="normal-mode"><span class="key">jk</span> normal mode</span>';
                break;
            case 'command':
                modeHint = '<span class="hint-action" data-action="normal-mode"><span class="key">Esc</span> cancel</span>';
                break;
            default: // normal mode
                modeHint = '<span class="hint-action" data-action="insert-mode"><span class="key">i</span> insert mode</span>';
                break;
        }
        hintsEl.innerHTML = saveHint + '&nbsp;&nbsp;' + modeHint + '&nbsp;&nbsp;' + focusHint;
    }

    // Handle clicks on hint actions (event delegation)
    hintsEl.addEventListener('click', function(e) {
        var target = e.target.closest('.hint-action');
        if (!target) return;
        var action = target.getAttribute('data-action');
        switch (action) {
            case 'save-close':
                if (vimEnabled && hasUnsavedChanges()) {
                    saveAndClose();
                } else if (vimEnabled) {
                    closeWithoutSaving();
                } else {
                    saveAndClose();
                }
                break;
            case 'insert-mode':
                switchToInsertMode();
                break;
            case 'normal-mode':
                switchToNormalMode();
                break;
            case 'toggle-focus':
                postMessage({ type: 'toggleFocusMode' });
                break;
        }
    });

    function hasUnsavedChanges() {
        return editor ? editor.getValue() !== originalContent : false;
    }

    function saveAndClose() {
        if (!editor) return;
        postMessage({ type: 'save', content: editor.getValue() });
    }

    function closeWithoutSaving() {
        postMessage({ type: 'close' });
    }

    function flashStatus(msg) {
        var prevHtml = hintsEl.innerHTML;
        hintsEl.innerHTML = '<span style="color:#ff6060;opacity:1">' + msg + '</span>';
        setTimeout(function() {
            if (hintsEl.textContent === msg) {
                hintsEl.innerHTML = prevHtml;
            }
        }, 2000);
    }

    // TextMate grammar setup — loaded asynchronously, replaces Monaco's built-in
    // Monarch tokenizer for markdown with VS Code's TextMate grammar.
    var textmateReady = false;

    function initTextMate() {
        if (typeof vscodetextmate === 'undefined' || typeof onig === 'undefined') {
            return; // Libraries not loaded, skip TextMate
        }

        fetch('monaco-editor://app/onig.wasm')
            .then(function(response) { return response.arrayBuffer(); })
            .then(function(wasmData) {
                return onig.loadWASM(wasmData);
            })
            .then(function() {
                var registry = new vscodetextmate.Registry({
                    onigLib: Promise.resolve({
                        createOnigScanner: function(patterns) { return onig.createOnigScanner(patterns); },
                        createOnigString: function(str) { return onig.createOnigString(str); }
                    }),
                    loadGrammar: function(scopeName) {
                        if (scopeName === 'text.html.markdown') {
                            return fetch('monaco-editor://app/markdown.tmLanguage.json')
                                .then(function(r) { return r.text(); })
                                .then(function(grammarText) {
                                    return vscodetextmate.parseRawGrammar(grammarText, 'markdown.tmLanguage.json');
                                });
                        }
                        return Promise.resolve(null);
                    }
                });

                return registry.loadGrammar('text.html.markdown');
            })
            .then(function(grammar) {
                if (!grammar) return;

                // State wrapper for Monaco's IState interface
                function TMState(ruleStack) {
                    this._ruleStack = ruleStack;
                }
                TMState.prototype.clone = function() {
                    return new TMState(this._ruleStack);
                };
                TMState.prototype.equals = function(other) {
                    return other instanceof TMState && other._ruleStack === this._ruleStack;
                };

                // Register TextMate-based token provider for markdown
                monaco.languages.setTokensProvider('markdown', {
                    getInitialState: function() {
                        return new TMState(vscodetextmate.INITIAL);
                    },
                    tokenize: function(line, state) {
                        var result = grammar.tokenizeLine(line, state._ruleStack);
                        var tokens = [];
                        for (var i = 0; i < result.tokens.length; i++) {
                            var t = result.tokens[i];
                            tokens.push({
                                startIndex: t.startIndex,
                                scopes: t.scopes[t.scopes.length - 1]
                            });
                        }
                        return {
                            tokens: tokens,
                            endState: new TMState(result.ruleStack)
                        };
                    }
                });

                textmateReady = true;
            })
            .catch(function(err) {
                // TextMate init failed — fall back to Monaco's built-in tokenizer silently
            });
    }

    require.config({ paths: { vs: 'vs' } });

    function registerCustomLanguages() {
        // OCaml — not in the standard Monaco bundle
        monaco.languages.register({ id: 'ocaml', extensions: ['.ml', '.mli'], aliases: ['OCaml', 'ocaml'] });
        monaco.languages.registerTokensProviderFactory('ocaml', {
            create: function() {
                return new Promise(function(resolve, reject) {
                    require(['vs/basic-languages/ocaml/ocaml'], resolve, reject);
                }).then(function(mod) { return mod.language; });
            }
        });
        monaco.languages.onLanguageEncountered('ocaml', function() {
            new Promise(function(resolve, reject) {
                require(['vs/basic-languages/ocaml/ocaml'], resolve, reject);
            }).then(function(mod) {
                monaco.languages.setLanguageConfiguration('ocaml', mod.conf);
            });
        });

        // TOML — not in the standard Monaco bundle
        monaco.languages.register({ id: 'toml', extensions: ['.toml'], aliases: ['TOML', 'toml'] });
        monaco.languages.registerTokensProviderFactory('toml', {
            create: function() {
                return new Promise(function(resolve, reject) {
                    require(['vs/basic-languages/toml/toml'], resolve, reject);
                }).then(function(mod) { return mod.language; });
            }
        });
        monaco.languages.onLanguageEncountered('toml', function() {
            new Promise(function(resolve, reject) {
                require(['vs/basic-languages/toml/toml'], resolve, reject);
            }).then(function(mod) {
                monaco.languages.setLanguageConfiguration('toml', mod.conf);
            });
        });

        // jq — not in the standard Monaco bundle
        monaco.languages.register({ id: 'jq', extensions: ['.jq'], aliases: ['jq'] });
        monaco.languages.registerTokensProviderFactory('jq', {
            create: function() {
                return new Promise(function(resolve, reject) {
                    require(['vs/basic-languages/jq/jq'], resolve, reject);
                }).then(function(mod) { return mod.language; });
            }
        });
        monaco.languages.onLanguageEncountered('jq', function() {
            new Promise(function(resolve, reject) {
                require(['vs/basic-languages/jq/jq'], resolve, reject);
            }).then(function(mod) {
                monaco.languages.setLanguageConfiguration('jq', mod.conf);
            });
        });
    }

    function initEditor() {
        if (typeof monaco === 'undefined') {
            setTimeout(initEditor, 100);
            return;
        }

        registerCustomLanguages();

        monaco.editor.defineTheme('freeboard-dark', {
            base: 'vs-dark',
            inherit: true,
            rules: [
                // TextMate scope mappings for markdown
                { token: 'markup.heading', foreground: '569cd6', fontStyle: 'bold' },
                { token: 'entity.name.section', foreground: '569cd6' },
                { token: 'punctuation.definition.heading', foreground: '569cd6' },
                { token: 'markup.bold', fontStyle: 'bold' },
                { token: 'markup.italic', fontStyle: 'italic' },
                { token: 'markup.inline.raw', foreground: 'ce9178' },
                { token: 'markup.fenced_code', foreground: 'ce9178' },
                { token: 'markup.raw', foreground: 'ce9178' },
                { token: 'string.other.link', foreground: '4ec9b0' },
                { token: 'markup.underline.link', foreground: '4ec9b0' },
                { token: 'comment.block.html', foreground: '6a9955' },
                { token: 'punctuation.definition.list', foreground: '569cd6' },
                { token: 'meta.separator', foreground: '569cd6' },
                { token: 'markup.quote', foreground: '6a9955' },
            ],
            colors: {
                'editor.background': '#0a0a0a',
                'editor.foreground': '#d4d4d4',
                'editorCursor.foreground': '#00ff40',
                'editor.selectionBackground': '#003a0d88',
                'editor.lineHighlightBackground': '#0d1a0d44'
            }
        });

        editor = monaco.editor.create(document.getElementById('editor-container'), {
            value: '',
            language: 'plaintext',
            theme: 'freeboard-dark',
            lineNumbers: 'off',
            minimap: { enabled: false },
            wordWrap: 'on',
            scrollBeyondLastLine: false,
            fontSize: 14,
            fontFamily: 'Menlo, monospace',
            renderLineHighlight: 'none',
            overviewRulerBorder: false,
            overviewRulerLanes: 0,
            hideCursorInOverviewRuler: true,
            scrollbar: {
                verticalScrollbarSize: 8,
                horizontalScrollbarSize: 8
            },
            padding: { top: 8, bottom: 8 },
            automaticLayout: true,
            contextmenu: false,
            tabSize: 2
        });

        // Non-vim Esc handling: save and close
        editor.addCommand(monaco.KeyCode.Escape, function() {
            if (!vimEnabled) {
                saveAndClose();
            }
        });

        // Cmd+F: toggle focus mode (override Monaco's default find widget)
        editor.addCommand(monaco.KeyMod.CtrlCmd | monaco.KeyCode.KeyF, function() {
            postMessage({ type: 'toggleFocusMode' });
        });

        // Don't focus here — only focus when setContent is called
        postMessage({ type: 'editorReady' });

        // Initialize TextMate grammar (async, non-blocking)
        initTextMate();
    }

    require(['vs/editor/editor.main'], function() {
        initEditor();
    }, function(err) {
        initEditor();
    });

    // Watch vim status changes to update hints, ensure command-line
    // input gets focus, and make the mode indicator clickable.
    //
    // IMPORTANT: monaco-vim's StatusBar creates child spans inside statusEl
    // (modeInfoNode, secInfoNode, notifNode, keyInfoNode) and holds references
    // to them. We must NEVER replace statusEl.innerHTML because that detaches
    // those nodes — the StatusBar would then write to orphaned DOM nodes and
    // the command-line input would never appear on screen.
    var updatingStatus = false;
    var observer = new MutationObserver(function() {
        if (updatingStatus) return;
        updateHints();

        if (vimEnabled) {
            // Make the vim mode indicator (e.g. "-- NORMAL --") clickable
            // by wrapping it in a span — but do so at the DOM level, never
            // by setting innerHTML on statusEl.
            //
            // monaco-vim's StatusBar structure:
            //   statusEl
            //     └─ modeInfoNode (span) ← contains text like "-- NORMAL --"
            //     └─ secInfoNode  (span) ← command-line input goes here
            //     └─ notifNode    (span)
            //     └─ keyInfoNode  (span)
            //
            // We wrap the text content *inside* modeInfoNode so StatusBar's
            // references remain valid.
            var modeInfoNode = statusEl.children[0]; // first child span
            var inCommandMode = !!statusEl.querySelector('input[type="text"]');
            if (modeInfoNode) {
                if (inCommandMode) {
                    // Hide the mode indicator (e.g. "-- NORMAL --") while the
                    // command-line input is active — showing "[Normal]" during
                    // command mode is confusing.
                    updatingStatus = true;
                    modeInfoNode.style.display = 'none';
                    updatingStatus = false;
                } else {
                    // Restore visibility when leaving command mode
                    if (modeInfoNode.style.display === 'none') {
                        updatingStatus = true;
                        modeInfoNode.style.display = '';
                        updatingStatus = false;
                    }
                    var modeText = modeInfoNode.textContent || '';
                    var modeMatch = modeText.match(/--(.*?)--/);
                    if (modeMatch && !modeInfoNode.querySelector('.vim-mode-toggle')) {
                        updatingStatus = true;
                        // Wrap the text node inside modeInfoNode with a clickable span
                        var wrapper = document.createElement('span');
                        wrapper.className = 'vim-mode-toggle';
                        wrapper.textContent = modeInfoNode.textContent;
                        modeInfoNode.textContent = '';
                        modeInfoNode.appendChild(wrapper);
                        updatingStatus = false;
                    }
                }
            }

            // Ensure command-line input gets focus (with retries for WKWebView)
            var input = statusEl.querySelector('input[type="text"]');
            if (input && document.activeElement !== input) {
                // Multiple focus attempts with increasing delays to handle
                // WKWebView's focus timing quirks
                input.focus();
                setTimeout(function() { if (document.activeElement !== input) input.focus(); }, 0);
                setTimeout(function() { if (document.activeElement !== input) input.focus(); }, 50);
                setTimeout(function() { if (document.activeElement !== input) input.focus(); }, 150);
            }
        }
    });
    observer.observe(statusEl, { childList: true, characterData: true, subtree: true });

    // Click handler for vim mode toggle in status bar
    statusEl.addEventListener('click', function(e) {
        var toggle = e.target.closest('.vim-mode-toggle');
        if (!toggle) return;
        if (isInsertMode()) {
            switchToNormalMode();
        } else {
            switchToInsertMode();
        }
    });

    // Register ex commands and mappings once on the global Vim singleton
    var vimCommandsRegistered = false;
    function registerVimCommands() {
        if (vimCommandsRegistered) return;
        vimCommandsRegistered = true;

        var Vim = MonacoVim.VimMode.Vim;

        // :w — save and close
        Vim.defineEx('write', 'w', function() {
            saveAndClose();
        });

        // :q — close only if no unsaved changes
        Vim.defineEx('quit', 'q', function(cm, params) {
            if (params && params.argString === '!') {
                closeWithoutSaving();
            } else if (hasUnsavedChanges()) {
                flashStatus('E37: No write since last change (add ! to override)');
            } else {
                closeWithoutSaving();
            }
        });

        // :wq — save and close
        Vim.defineEx('wquit', 'wq', function() {
            saveAndClose();
        });

        // :x — save and close (only writes if changed, like vim)
        Vim.defineEx('x', 'x', function() {
            if (hasUnsavedChanges()) {
                saveAndClose();
            } else {
                closeWithoutSaving();
            }
        });

        // jk to exit insert mode
        Vim.map('jk', '<Esc>', 'insert');

        // Esc in normal mode to save and close.
        // Define a custom action and map it properly — mapCommand with
        // an empty type string silently does nothing.
        Vim.defineAction('saveAndClose', function() {
            saveAndClose();
        });
        Vim.mapCommand('<Esc>', 'action', 'saveAndClose', {}, { context: 'normal' });

        // :set nu / :set number — show line numbers
        Vim.defineEx('set', 'set', function(cm, params) {
            var arg = (params.argString || '').trim();
            if (arg === 'nu' || arg === 'number') {
                editor.updateOptions({ lineNumbers: 'on' });
            } else if (arg === 'nonu' || arg === 'nonumber') {
                editor.updateOptions({ lineNumbers: 'off' });
            }
        });
    }

    function enableVim() {
        if (vimModeInstance) {
            vimModeInstance.dispose();
            vimModeInstance = null;
        }

        if (typeof MonacoVim !== 'undefined' && MonacoVim.initVimMode) {
            vimModeInstance = MonacoVim.initVimMode(editor, statusEl);
            registerVimCommands();
        }
        updateHints();
    }

    function disableVim() {
        if (vimModeInstance) {
            vimModeInstance.dispose();
            vimModeInstance = null;
        }
        statusEl.textContent = '';
        updateHints();
    }

    // Language detection heuristics — analyzes text content to determine
    // the programming language for syntax highlighting.
    // Markdown has HIGHER priority than code detection because the TextMate
    // grammar was specifically set up for markdown rendering.
    // Only detects languages with tokenizers in vs/basic-languages/:
    //   c, cpp, csharp, go, java, javascript, jq, json, kotlin, lua, markdown,
    //   ocaml, php, python, ruby, rust, shell, sql, swift, toml, typescript, xml
    function detectLanguage(text) {
        var trimmed = text.replace(/^\s+|\s+$/g, '');
        if (!trimmed) return 'plaintext';

        // --- JSON: starts with { or [ and looks like JSON ---
        var firstChar = trimmed.charAt(0);
        if (firstChar === '{' || firstChar === '[') {
            try {
                JSON.parse(trimmed);
                return 'json';
            } catch (e) {
                // Might still be JSON-like but malformed, or could be code
                // Check if it looks like a JS/TS object literal instead
                if (firstChar === '{' && /^\{[\s\S]*"[^"]*"\s*:/.test(trimmed)) {
                    return 'json';
                }
            }
        }

        // --- XML/HTML: starts with < and looks like markup ---
        if (/^<[?!a-zA-Z]/.test(trimmed)) return 'xml';

        // --- SQL: starts with SQL keywords ---
        var upper = trimmed.toUpperCase();
        var sqlStarts = ['SELECT ', 'INSERT ', 'UPDATE ', 'DELETE ', 'CREATE TABLE',
                         'ALTER TABLE', 'DROP TABLE', 'CREATE INDEX', 'SELECT\n',
                         'INSERT\n', 'WITH '];
        for (var s = 0; s < sqlStarts.length; s++) {
            if (upper.indexOf(sqlStarts[s]) === 0) return 'sql';
        }
        // Also check for multi-line SQL (e.g., comments then SELECT)
        if (/^--.*\n\s*(SELECT|INSERT|UPDATE|DELETE|CREATE|ALTER|DROP)\b/i.test(trimmed)) {
            return 'sql';
        }

        // --- Shell: shebang or shell-specific patterns ---
        if (/^#!\/bin\//.test(trimmed) || /^#!\/usr\/bin\/env\s/.test(trimmed)) return 'shell';

        // --- TOML: section headers and key = value patterns, no code constructs ---
        var tomlSectionCount = (trimmed.match(/^\[[\w\.\-]+\]/gm) || []).length;
        var tomlKVCount = (trimmed.match(/^[\w\.\-]+\s*=\s*.+/gm) || []).length;
        if (tomlSectionCount >= 1 && tomlKVCount >= 2) return 'toml';
        // Pure key=value without sections (e.g. pyproject.toml fragments)
        if (tomlKVCount >= 3 && !/\b(function|def|class|var|const|let|import)\b/.test(trimmed)) return 'toml';

        // --- Markdown detection (HIGHER priority than code) ---
        var lines = trimmed.split('\n');
        var mdScore = 0;
        var totalLines = Math.min(lines.length, 100); // sample first 100 lines
        for (var i = 0; i < totalLines; i++) {
            var ln = lines[i].replace(/^\s+/, '');
            if (/^#{1,6}\s/.test(ln)) mdScore += 3;              // headings
            if (/^[-+*]\s/.test(ln)) mdScore += 1;                // unordered lists
            if (/^\d+\.\s/.test(ln)) mdScore += 1;                // ordered lists
            if (/^```/.test(ln) || /^~~~/.test(ln)) mdScore += 3; // code fences
            if (/^>\s/.test(ln)) mdScore += 1;                    // blockquotes
            if (/\[.*?\]\(.*?\)/.test(ln)) mdScore += 2;          // links
            if (/\*\*.*?\*\*/.test(ln) || /__.*?__/.test(ln)) mdScore += 1; // bold
            if (/^\|.*\|/.test(ln)) mdScore += 1;                 // tables
            if (/^---+$/.test(ln) || /^===+$/.test(ln)) mdScore += 1; // hr / setext heading
        }
        // If there's meaningful markdown structure, use markdown
        if (mdScore >= 3) return 'markdown';

        // --- Rust (check before Swift because both have `func`/`struct`/`enum`) ---
        if (/\bfn\s+\w+\s*[\(<]/.test(trimmed) && (/\blet\s+(mut\s+)?\w+/.test(trimmed) || /->/.test(trimmed))) return 'rust';
        if (/\buse\s+std::/.test(trimmed) || /\buse\s+crate::/.test(trimmed)) return 'rust';
        if (/\bpub\s+fn\s/.test(trimmed) || /\bpub\s+struct\s/.test(trimmed) || /\bpub\s+enum\s/.test(trimmed)) return 'rust';
        if (/\bimpl\s+\w+/.test(trimmed) && /\bfn\s/.test(trimmed)) return 'rust';
        if (/\blet\s+mut\s/.test(trimmed) && /\bfn\s/.test(trimmed)) return 'rust';
        if (/\b(println|eprintln|format|vec|panic)!\s*\(/.test(trimmed)) return 'rust';
        if (/\bmod\s+\w+\s*\{/.test(trimmed) && /\bfn\s/.test(trimmed)) return 'rust';

        // --- Go ---
        if (/\bpackage\s+\w+/.test(trimmed) && /\bfunc\s/.test(trimmed)) return 'go';
        if (/\bfunc\s+\w+\s*\(/.test(trimmed) && /\b:=\b/.test(trimmed)) return 'go';
        if (/\bfunc\s+\(\w+\s+\*?\w+\)\s+\w+/.test(trimmed)) return 'go'; // method receiver
        if (/\bimport\s+\(/.test(trimmed) && /\bfunc\s/.test(trimmed)) return 'go';
        if (/\bgo\s+func\s*\(/.test(trimmed)) return 'go';
        if (/\bchan\s+\w+/.test(trimmed) || /\b<-\s*chan\b/.test(trimmed)) return 'go';
        if (/\bpackage\s+main\b/.test(trimmed)) return 'go';
        if (/\bdefer\s+\w+/.test(trimmed) && /\bfunc\b/.test(trimmed)) return 'go';
        if (/\bfmt\.\w+/.test(trimmed) && /\bfunc\s/.test(trimmed)) return 'go';

        // --- OCaml ---
        if (/\blet\s+\w+\s*=/.test(trimmed) && /\bmatch\b/.test(trimmed) && /\bwith\b/.test(trimmed)) return 'ocaml';
        if (/\bmodule\s+\w+\s*=\s*struct\b/.test(trimmed)) return 'ocaml';
        if (/\bsig\b/.test(trimmed) && /\bval\b/.test(trimmed)) return 'ocaml';
        if (/\blet\s+rec\s+\w+/.test(trimmed)) return 'ocaml';
        if (/\btype\s+\w+\s*=/.test(trimmed) && /\|/.test(trimmed) && !/\b(const|let|var|interface)\b/.test(trimmed)) return 'ocaml';
        if (/\bfun\s+\w+\s*->/.test(trimmed)) return 'ocaml';
        if (/\bopen\s+\w+/.test(trimmed) && /\blet\s/.test(trimmed) && !/\b(const|var|function)\b/.test(trimmed)) return 'ocaml';

        // --- PHP ---
        if (/^<\?php\b/.test(trimmed) || /^<\?=/.test(trimmed)) return 'php';
        if (/\$\w+\s*=/.test(trimmed) && /\bfunction\b/.test(trimmed)) return 'php';
        if (/\$\w+\s*->/.test(trimmed) || /\$this\s*->/.test(trimmed)) return 'php';
        if (/\bnamespace\s+[\w\\]+;/.test(trimmed) && /\buse\s+[\w\\]+/.test(trimmed)) return 'php';
        if (/\becho\s+/.test(trimmed) && /\$\w+/.test(trimmed)) return 'php';

        // --- C# ---
        if (/\busing\s+System\b/.test(trimmed)) return 'csharp';
        if (/\bnamespace\s+\w+/.test(trimmed) && /\bclass\s+\w+/.test(trimmed) && /\{/.test(trimmed)) return 'csharp';
        if (/\b(public|private|protected|internal)\s+(static\s+)?(void|int|string|bool|class|async)\s/.test(trimmed) && /\bnamespace\b/.test(trimmed)) return 'csharp';
        if (/\bConsole\.(WriteLine|ReadLine|Write)\s*\(/.test(trimmed)) return 'csharp';
        if (/\bvar\s+\w+\s*=/.test(trimmed) && /\bnamespace\b/.test(trimmed)) return 'csharp';

        // --- Java ---
        if (/\bimport\s+java\./.test(trimmed) || /\bimport\s+javax\./.test(trimmed)) return 'java';
        if (/\bimport\s+org\.(springframework|apache|junit)/.test(trimmed)) return 'java';
        if (/\bpublic\s+class\s+\w+/.test(trimmed) && /\bvoid\s+\w+\s*\(/.test(trimmed)) return 'java';
        if (/\bSystem\.out\.(println|print|printf)\s*\(/.test(trimmed)) return 'java';
        if (/\bpublic\s+static\s+void\s+main\s*\(/.test(trimmed)) return 'java';
        if (/\bpackage\s+[\w.]+;/.test(trimmed) && /\bclass\s/.test(trimmed)) return 'java';

        // --- Kotlin ---
        if (/\bimport\s+kotlin\./.test(trimmed) || /\bimport\s+kotlinx\./.test(trimmed)) return 'kotlin';
        if (/\bfun\s+\w+\s*\(/.test(trimmed) && /\bval\s+\w+/.test(trimmed)) return 'kotlin';
        if (/\bfun\s+\w+\s*\(/.test(trimmed) && /\bvar\s+\w+/.test(trimmed)) return 'kotlin';
        if (/\bfun\s+main\s*\(/.test(trimmed) && /\bprintln\s*\(/.test(trimmed)) return 'kotlin';
        if (/\bdata\s+class\s+\w+/.test(trimmed)) return 'kotlin';
        if (/\bsealed\s+class\s+\w+/.test(trimmed)) return 'kotlin';
        if (/\bobject\s+\w+\s*:/.test(trimmed) && /\bfun\b/.test(trimmed)) return 'kotlin';
        if (/\bsuspend\s+fun\b/.test(trimmed)) return 'kotlin';

        // --- C / C++ ---
        if (/^#include\s*[<"]/.test(trimmed)) return 'cpp';
        if (/\bint\s+main\s*\(/.test(trimmed) && !/\bpackage\b/.test(trimmed)) return 'cpp';
        if (/\bstd::/.test(trimmed)) return 'cpp';
        if (/\b(cout|cin|cerr|endl)\b/.test(trimmed) && /<</.test(trimmed)) return 'cpp';
        if (/\bprintf\s*\(/.test(trimmed) && /^#/.test(trimmed)) return 'c';
        if (/\btemplate\s*</.test(trimmed) && /\bclass\b/.test(trimmed)) return 'cpp';
        if (/\bnamespace\s+\w+\s*\{/.test(trimmed) && /\bclass\b/.test(trimmed) && !/\busing\s+System/.test(trimmed)) return 'cpp';
        if (/\bvirtual\s+(void|int|bool|~)/.test(trimmed)) return 'cpp';
        if (/\bprintf\s*\(/.test(trimmed) && /\b(int|void|char|float|double)\s+\w+/.test(trimmed)) return 'c';

        // --- Ruby ---
        if (/^require\s+['"]/.test(trimmed) || /^require_relative\s+['"]/.test(trimmed)) return 'ruby';
        if (/\bdef\s+\w+/.test(trimmed) && /\bend\b/.test(trimmed) && !/:\s*$/.test(trimmed.split('\n')[0])) return 'ruby';
        if (/\battr_(reader|writer|accessor)\s+:/.test(trimmed)) return 'ruby';
        if (/\bputs\s+/.test(trimmed) && /\bdef\s/.test(trimmed)) return 'ruby';
        if (/\bclass\s+\w+\s*<\s*\w+/.test(trimmed) && /\bdef\b/.test(trimmed)) return 'ruby';
        if (/\bdo\s*\|/.test(trimmed) && /\.each\b/.test(trimmed)) return 'ruby';
        if (/\bmodule\s+\w+/.test(trimmed) && /\bdef\b/.test(trimmed) && /\bend\b/.test(trimmed)) return 'ruby';

        // --- Lua ---
        if (/\blocal\s+\w+\s*=/.test(trimmed) && /\bfunction\b/.test(trimmed) && /\bend\b/.test(trimmed)) return 'lua';
        if (/\blocal\s+function\s+\w+/.test(trimmed)) return 'lua';
        if (/\bfunction\s+\w+\s*\(/.test(trimmed) && /\bend\b/.test(trimmed) && !/\b(const|let|var|class)\b/.test(trimmed)) return 'lua';
        if (/\bif\b.*\bthen\b/.test(trimmed) && /\bend\b/.test(trimmed) && !/\b(const|let|var|function\s*\()\b/.test(trimmed)) return 'lua';
        if (/\brequire\s*\(?\s*['"]/.test(trimmed) && /\blocal\b/.test(trimmed)) return 'lua';

        // --- jq ---
        if (/^\.\w+/.test(trimmed) && /\|\s*(select|map|keys|values|length|sort_by|group_by|to_entries|from_entries)\s*\(/.test(trimmed)) return 'jq';
        if (/\|\s*\.\w+/.test(trimmed) && /\|\s*(select|map)\s*\(/.test(trimmed)) return 'jq';
        if (/@(csv|tsv|json|text|html|base64|base64d|uri|sh)\b/.test(trimmed) && /\|/.test(trimmed)) return 'jq';
        if (/\bdef\s+\w+\s*:/.test(trimmed) && /\.\w+/.test(trimmed) && /\|/.test(trimmed)) return 'jq';
        // Pipe-heavy jq expressions with field access
        var jqPipes = (trimmed.match(/\|/g) || []).length;
        var jqFields = (trimmed.match(/\.\w+/g) || []).length;
        if (jqPipes >= 2 && jqFields >= 2 && !/\b(function|def |class|import|from|const|let|var)\b/.test(trimmed)) return 'jq';

        // --- Swift ---
        // Strong indicators: Swift-specific imports
        if (/\bimport\s+(Foundation|UIKit|SwiftUI|Cocoa|AppKit|Combine|CoreData)\b/.test(trimmed)) return 'swift';
        // Swift-specific syntax patterns
        if (/\bfunc\s+\w+\s*\(/.test(trimmed) && (/\b(let|var)\s+\w+\s*[=:]/.test(trimmed) || /\s*->\s*/.test(trimmed))) return 'swift';
        if (/\bstruct\s+\w+\s*:\s*\w+/.test(trimmed) || /\benum\s+\w+\s*:\s*\w+/.test(trimmed)) return 'swift';
        if (/\bguard\s+let\b/.test(trimmed) || /\bif\s+let\b/.test(trimmed)) return 'swift';
        if (/@objc\b/.test(trimmed) || /@IBOutlet\b/.test(trimmed) || /@IBAction\b/.test(trimmed)) return 'swift';
        if (/\bprotocol\s+\w+\s*:\s*\w+/.test(trimmed) && /\bfunc\b/.test(trimmed)) return 'swift';

        // --- Python ---
        if (/^(from|import)\s+\w+/.test(trimmed) && !/\bfunction\b/.test(trimmed) && !/\bconst\b/.test(trimmed)) return 'python';
        if (/\bdef\s+\w+\s*\(/.test(trimmed) && /:\s*$/.test(trimmed.split('\n')[0])) return 'python';
        if (/\bif\s+__name__\s*==/.test(trimmed)) return 'python';
        if (/\bclass\s+\w+\s*(\(.*\))?\s*:/.test(trimmed) && !/\{/.test(trimmed)) return 'python';
        // Python-style function defs (multiple)
        var pyDefCount = (trimmed.match(/\bdef\s+\w+\s*\(/g) || []).length;
        if (pyDefCount >= 2) return 'python';

        // --- TypeScript (check before JavaScript since TS is a superset) ---
        if (/\binterface\s+\w+\s*\{/.test(trimmed)) return 'typescript';
        if (/\btype\s+\w+\s*=/.test(trimmed) && (/\bconst\b/.test(trimmed) || /\blet\b/.test(trimmed))) return 'typescript';
        if (/:\s*(string|number|boolean|void|any|never|unknown)\b/.test(trimmed) && /\b(const|let|function|class)\b/.test(trimmed)) return 'typescript';
        if (/\bas\s+(string|number|boolean|any)\b/.test(trimmed)) return 'typescript';
        if (/\b(export|import)\s+.*\bfrom\s+['"]/.test(trimmed) && /:\s*\w+/.test(trimmed)) return 'typescript';

        // --- JavaScript ---
        if (/\bfunction\s+\w+\s*\(/.test(trimmed) || /\bfunction\s*\(/.test(trimmed)) return 'javascript';
        if (/\b(const|let|var)\s+\w+\s*=/.test(trimmed) && (/=>/.test(trimmed) || /\bfunction\b/.test(trimmed) || /\brequire\s*\(/.test(trimmed))) return 'javascript';
        if (/\bmodule\.exports\b/.test(trimmed) || /\brequire\s*\(['"]/.test(trimmed)) return 'javascript';
        if (/\b(export|import)\s+.*\bfrom\s+['"]/.test(trimmed)) return 'javascript';
        if (/\bconsole\.\w+\s*\(/.test(trimmed)) return 'javascript';
        if (/\basync\s+(function|\()/.test(trimmed) || /\bawait\s+/.test(trimmed)) return 'javascript';

        // --- Shell (broader patterns, after shebang check above) ---
        if (/^(export|alias|source|eval)\s+/.test(trimmed)) return 'shell';
        if (/\|\s*(grep|awk|sed|sort|uniq|cut|tr|wc|head|tail)\b/.test(trimmed)) return 'shell';
        if (/\$\(.*\)/.test(trimmed) && !/\b(const|let|var|function)\b/.test(trimmed)) return 'shell';
        if (/\bif\s+\[\[?\s/.test(trimmed) && /\bthen\b/.test(trimmed)) return 'shell';
        if (/\bfor\s+\w+\s+in\b/.test(trimmed) && /\bdo\b/.test(trimmed)) return 'shell';

        // --- SQL (broader patterns) ---
        var sqlKeywords = (upper.match(/\b(SELECT|FROM|WHERE|JOIN|INSERT|UPDATE|DELETE|CREATE|ALTER|DROP|TABLE|INDEX|ORDER BY|GROUP BY|HAVING)\b/g) || []);
        if (sqlKeywords.length >= 3) return 'sql';

        // --- Weak Swift detection (after stronger language checks) ---
        if (/\bfunc\s+\w+\s*\(/.test(trimmed) && /\b(let|var)\s/.test(trimmed)) return 'swift';
        if (/\bprint\s*\("/.test(trimmed) && /\b(let|var|func)\b/.test(trimmed)) return 'swift';

        // --- Weak Python detection ---
        if (/\bprint\s*\(/.test(trimmed) && /\bdef\s+/.test(trimmed)) return 'python';

        // --- Weak JS detection ---
        if (/\b(const|let)\s+\w+\s*=/.test(trimmed)) return 'javascript';

        // Nothing detected — use what Swift sent, or plaintext
        return null;
    }

    // Public API called from Swift
    window.setContent = function(text, language, isVimEnabled) {
        if (!editor) {
            setTimeout(function() { window.setContent(text, language, isVimEnabled); }, 100);
            return;
        }
        // Run JS-side language detection; fall back to Swift-provided language
        var detected = detectLanguage(text);
        var finalLang = detected || language || 'plaintext';
        var model = editor.getModel();
        monaco.editor.setModelLanguage(model, finalLang);
        editor.setValue(text);
        originalContent = text;
        vimEnabled = isVimEnabled;
        if (vimEnabled) {
            enableVim();
        } else {
            disableVim();
        }
        editor.focus();
    };

    window.getContent = function() {
        return editor ? editor.getValue() : '';
    };

    window.setFocusMode = function(enabled) {
        focusModeActive = enabled;
        if (editor) {
            // Show line numbers in focus mode, hide in regular mode
            editor.updateOptions({ lineNumbers: enabled ? 'on' : 'off' });
        }
        updateHints();
    };

    updateHints();
})();
</script>
</body>
</html>
