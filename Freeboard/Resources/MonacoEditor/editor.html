<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<link rel="stylesheet" type="text/css" href="vs/editor/editor.main.css">
<style>
    html, body {
        margin: 0;
        padding: 0;
        width: 100%;
        height: 100%;
        overflow: hidden;
        background: #0a0a0a;
    }
    #editor-container {
        width: 100%;
        height: calc(100% - 22px);
    }
    #status-bar {
        position: fixed;
        bottom: 0;
        left: 0;
        right: 0;
        height: 22px;
        background: #1e1e1e;
        font-family: Menlo, monospace;
        font-size: 11px;
        line-height: 22px;
        padding: 0 8px;
        z-index: 1000;
        border-top: 1px solid #333;
        display: flex;
        justify-content: space-between;
        align-items: center;
    }
    #vim-status {
        color: #d4d4d4;
        flex-shrink: 0;
        flex-grow: 1;
    }
    /* Vim command-line input (created by monaco-vim inside #vim-status > secInfoNode) */
    #vim-status input[type="text"] {
        background: #1e1e1e !important;
        color: #d4d4d4 !important;
        border: none !important;
        outline: none !important;
        font-family: Menlo, monospace !important;
        font-size: 11px !important;
        line-height: 22px !important;
        height: 20px !important;
        width: 200px;
        min-width: 100px;
        max-width: 60%;
        padding: 0 !important;
        margin: 0 2px !important;
        caret-color: #00ff40 !important;
        display: inline-block !important;
        opacity: 1 !important;
        visibility: visible !important;
        position: static !important;
    }
    #editor-hints {
        color: #00c030;
        opacity: 0.5;
        white-space: nowrap;
        flex-shrink: 1;
        min-width: 0;
    }
    #editor-hints .key {
        color: #00ff40;
        opacity: 1;
    }
    /* Clickable hint buttons */
    #editor-hints .hint-action {
        cursor: pointer;
        display: inline;
        border: none;
        background: none;
        padding: 0;
        margin: 0;
        font: inherit;
        color: inherit;
        opacity: inherit;
        line-height: inherit;
        -webkit-user-select: none;
        user-select: none;
    }
    #editor-hints .hint-action:hover {
        opacity: 1;
    }
    #editor-hints .hint-action:hover .key {
        text-decoration: underline;
    }
    /* Clickable vim mode indicator in status bar */
    #vim-status .vim-mode-toggle {
        cursor: pointer;
        -webkit-user-select: none;
        user-select: none;
    }
    #vim-status .vim-mode-toggle:hover {
        text-decoration: underline;
    }
</style>
</head>
<body>
<div id="editor-container"></div>
<div id="status-bar">
    <div id="vim-status"></div>
    <div id="editor-hints"></div>
</div>

<script src="vs/loader.js"></script>
<script src="vs/editor/editor.main.nls.js"></script>
<script src="vs/editor/editor.main.js"></script>
<!-- Load UMD libraries with AMD hidden so they use global assignment path -->
<script>var __define = define; define = undefined;</script>
<script src="monaco-vim.js"></script>
<script src="vscode-textmate.js"></script>
<script src="vscode-oniguruma.js"></script>
<script>define = __define;</script>
<script>
(function() {
    var editor = null;
    var vimEnabled = false;
    var vimModeInstance = null;
    var originalContent = '';
    var statusEl = document.getElementById('vim-status');
    var hintsEl = document.getElementById('editor-hints');
    var editorContainerEl = document.getElementById('editor-container');

    function postMessage(msg) {
        if (window.webkit && window.webkit.messageHandlers && window.webkit.messageHandlers.editorBridge) {
            window.webkit.messageHandlers.editorBridge.postMessage(msg);
        }
    }

    function getVimMode() {
        var statusText = statusEl.textContent || '';
        if (statusText.indexOf('INSERT') !== -1) return 'insert';
        if (statusText.indexOf('REPLACE') !== -1) return 'replace';
        if (statusText.indexOf('VISUAL BLOCK') !== -1) return 'visual-block';
        if (statusText.indexOf('VISUAL LINE') !== -1) return 'visual-line';
        if (statusText.indexOf('VISUAL') !== -1) return 'visual';
        // Command-line mode: monaco-vim renders an input field inside #vim-status
        if (statusEl.querySelector('input[type="text"]')) return 'command';
        return 'normal';
    }

    function isInsertMode() {
        var mode = getVimMode();
        return mode === 'insert' || mode === 'replace';
    }

    function switchToInsertMode() {
        if (!editor || !vimEnabled || getVimMode() === 'insert') return;
        editor.focus();
        // Use the Vim API to send 'i' key to enter insert mode.
        // vimModeInstance is the CodeMirror adapter that Vim.handleKey expects.
        if (vimModeInstance && typeof MonacoVim !== 'undefined') {
            MonacoVim.VimMode.Vim.handleKey(vimModeInstance, 'i');
        }
    }

    function switchToNormalMode() {
        if (!editor || !vimEnabled || getVimMode() === 'normal') return;
        editor.focus();
        if (vimModeInstance && typeof MonacoVim !== 'undefined') {
            MonacoVim.VimMode.Vim.handleKey(vimModeInstance, '<Esc>');
        }
    }

    function updateHints() {
        if (!vimEnabled) {
            hintsEl.innerHTML = '<span class="hint-action" data-action="save-close"><span class="key">Esc</span> save+close</span>';
            return;
        }
        var mode = getVimMode();
        var saveHint = '<span class="hint-action" data-action="save-close"><span class="key">:x</span> save+close</span>';
        var modeHint;
        switch (mode) {
            case 'insert':
                modeHint = '<span class="hint-action" data-action="normal-mode"><span class="key">Esc</span> normal mode</span>';
                break;
            case 'replace':
                modeHint = '<span class="hint-action" data-action="normal-mode"><span class="key">Esc</span> normal mode</span>';
                break;
            case 'visual':
            case 'visual-line':
            case 'visual-block':
                modeHint = '<span class="hint-action" data-action="normal-mode"><span class="key">Esc</span> normal mode</span>';
                break;
            case 'command':
                modeHint = '<span class="hint-action" data-action="normal-mode"><span class="key">Esc</span> cancel</span>';
                break;
            default: // normal mode
                modeHint = '<span class="hint-action" data-action="insert-mode"><span class="key">i</span> insert mode</span>';
                break;
        }
        hintsEl.innerHTML = saveHint + '&nbsp;&nbsp;' + modeHint;
    }

    // Handle clicks on hint actions (event delegation)
    hintsEl.addEventListener('click', function(e) {
        var target = e.target.closest('.hint-action');
        if (!target) return;
        var action = target.getAttribute('data-action');
        switch (action) {
            case 'save-close':
                if (vimEnabled && hasUnsavedChanges()) {
                    saveAndClose();
                } else if (vimEnabled) {
                    closeWithoutSaving();
                } else {
                    saveAndClose();
                }
                break;
            case 'insert-mode':
                switchToInsertMode();
                break;
            case 'normal-mode':
                switchToNormalMode();
                break;
        }
    });

    function hasUnsavedChanges() {
        return editor ? editor.getValue() !== originalContent : false;
    }

    function saveAndClose() {
        if (!editor) return;
        postMessage({ type: 'save', content: editor.getValue() });
    }

    function closeWithoutSaving() {
        postMessage({ type: 'close' });
    }

    function flashStatus(msg) {
        var prevHtml = hintsEl.innerHTML;
        hintsEl.innerHTML = '<span style="color:#ff6060;opacity:1">' + msg + '</span>';
        setTimeout(function() {
            if (hintsEl.textContent === msg) {
                hintsEl.innerHTML = prevHtml;
            }
        }, 2000);
    }

    // TextMate grammar setup — loaded asynchronously, replaces Monaco's built-in
    // Monarch tokenizer for markdown with VS Code's TextMate grammar.
    var textmateReady = false;

    function initTextMate() {
        if (typeof vscodetextmate === 'undefined' || typeof onig === 'undefined') {
            return; // Libraries not loaded, skip TextMate
        }

        fetch('monaco-editor://app/onig.wasm')
            .then(function(response) { return response.arrayBuffer(); })
            .then(function(wasmData) {
                return onig.loadWASM(wasmData);
            })
            .then(function() {
                var registry = new vscodetextmate.Registry({
                    onigLib: Promise.resolve({
                        createOnigScanner: function(patterns) { return onig.createOnigScanner(patterns); },
                        createOnigString: function(str) { return onig.createOnigString(str); }
                    }),
                    loadGrammar: function(scopeName) {
                        if (scopeName === 'text.html.markdown') {
                            return fetch('monaco-editor://app/markdown.tmLanguage.json')
                                .then(function(r) { return r.text(); })
                                .then(function(grammarText) {
                                    return vscodetextmate.parseRawGrammar(grammarText, 'markdown.tmLanguage.json');
                                });
                        }
                        return Promise.resolve(null);
                    }
                });

                return registry.loadGrammar('text.html.markdown');
            })
            .then(function(grammar) {
                if (!grammar) return;

                // State wrapper for Monaco's IState interface
                function TMState(ruleStack) {
                    this._ruleStack = ruleStack;
                }
                TMState.prototype.clone = function() {
                    return new TMState(this._ruleStack);
                };
                TMState.prototype.equals = function(other) {
                    return other instanceof TMState && other._ruleStack === this._ruleStack;
                };

                // Register TextMate-based token provider for markdown
                monaco.languages.setTokensProvider('markdown', {
                    getInitialState: function() {
                        return new TMState(vscodetextmate.INITIAL);
                    },
                    tokenize: function(line, state) {
                        var result = grammar.tokenizeLine(line, state._ruleStack);
                        var tokens = [];
                        for (var i = 0; i < result.tokens.length; i++) {
                            var t = result.tokens[i];
                            tokens.push({
                                startIndex: t.startIndex,
                                scopes: t.scopes[t.scopes.length - 1]
                            });
                        }
                        return {
                            tokens: tokens,
                            endState: new TMState(result.ruleStack)
                        };
                    }
                });

                textmateReady = true;
            })
            .catch(function(err) {
                // TextMate init failed — fall back to Monaco's built-in tokenizer silently
            });
    }

    require.config({ paths: { vs: 'vs' } });

    function initEditor() {
        if (typeof monaco === 'undefined') {
            setTimeout(initEditor, 100);
            return;
        }

        monaco.editor.defineTheme('freeboard-dark', {
            base: 'vs-dark',
            inherit: true,
            rules: [
                // TextMate scope mappings for markdown
                { token: 'markup.heading', foreground: '569cd6', fontStyle: 'bold' },
                { token: 'entity.name.section', foreground: '569cd6' },
                { token: 'punctuation.definition.heading', foreground: '569cd6' },
                { token: 'markup.bold', fontStyle: 'bold' },
                { token: 'markup.italic', fontStyle: 'italic' },
                { token: 'markup.inline.raw', foreground: 'ce9178' },
                { token: 'markup.fenced_code', foreground: 'ce9178' },
                { token: 'markup.raw', foreground: 'ce9178' },
                { token: 'string.other.link', foreground: '4ec9b0' },
                { token: 'markup.underline.link', foreground: '4ec9b0' },
                { token: 'comment.block.html', foreground: '6a9955' },
                { token: 'punctuation.definition.list', foreground: '569cd6' },
                { token: 'meta.separator', foreground: '569cd6' },
                { token: 'markup.quote', foreground: '6a9955' },
            ],
            colors: {
                'editor.background': '#0a0a0a',
                'editor.foreground': '#d4d4d4',
                'editorCursor.foreground': '#00ff40',
                'editor.selectionBackground': '#003a0d88',
                'editor.lineHighlightBackground': '#0d1a0d44'
            }
        });

        editor = monaco.editor.create(document.getElementById('editor-container'), {
            value: '',
            language: 'plaintext',
            theme: 'freeboard-dark',
            lineNumbers: 'off',
            minimap: { enabled: false },
            wordWrap: 'on',
            scrollBeyondLastLine: false,
            fontSize: 14,
            fontFamily: 'Menlo, monospace',
            renderLineHighlight: 'none',
            overviewRulerBorder: false,
            overviewRulerLanes: 0,
            hideCursorInOverviewRuler: true,
            scrollbar: {
                verticalScrollbarSize: 8,
                horizontalScrollbarSize: 8
            },
            padding: { top: 8, bottom: 8 },
            automaticLayout: true,
            contextmenu: false,
            tabSize: 2
        });

        // Non-vim Esc handling: save and close
        editor.addCommand(monaco.KeyCode.Escape, function() {
            if (!vimEnabled) {
                saveAndClose();
            }
        });

        // Don't focus here — only focus when setContent is called
        postMessage({ type: 'editorReady' });

        // Initialize TextMate grammar (async, non-blocking)
        initTextMate();
    }

    require(['vs/editor/editor.main'], function() {
        initEditor();
    }, function(err) {
        initEditor();
    });

    // Watch vim status changes to update hints, ensure command-line
    // input gets focus, and make the mode indicator clickable.
    //
    // IMPORTANT: monaco-vim's StatusBar creates child spans inside statusEl
    // (modeInfoNode, secInfoNode, notifNode, keyInfoNode) and holds references
    // to them. We must NEVER replace statusEl.innerHTML because that detaches
    // those nodes — the StatusBar would then write to orphaned DOM nodes and
    // the command-line input would never appear on screen.
    var updatingStatus = false;
    var observer = new MutationObserver(function() {
        if (updatingStatus) return;
        updateHints();

        if (vimEnabled) {
            // Make the vim mode indicator (e.g. "-- NORMAL --") clickable
            // by wrapping it in a span — but do so at the DOM level, never
            // by setting innerHTML on statusEl.
            //
            // monaco-vim's StatusBar structure:
            //   statusEl
            //     └─ modeInfoNode (span) ← contains text like "-- NORMAL --"
            //     └─ secInfoNode  (span) ← command-line input goes here
            //     └─ notifNode    (span)
            //     └─ keyInfoNode  (span)
            //
            // We wrap the text content *inside* modeInfoNode so StatusBar's
            // references remain valid.
            var modeInfoNode = statusEl.children[0]; // first child span
            var inCommandMode = !!statusEl.querySelector('input[type="text"]');
            if (modeInfoNode) {
                if (inCommandMode) {
                    // Hide the mode indicator (e.g. "-- NORMAL --") while the
                    // command-line input is active — showing "[Normal]" during
                    // command mode is confusing.
                    updatingStatus = true;
                    modeInfoNode.style.display = 'none';
                    updatingStatus = false;
                } else {
                    // Restore visibility when leaving command mode
                    if (modeInfoNode.style.display === 'none') {
                        updatingStatus = true;
                        modeInfoNode.style.display = '';
                        updatingStatus = false;
                    }
                    var modeText = modeInfoNode.textContent || '';
                    var modeMatch = modeText.match(/--(.*?)--/);
                    if (modeMatch && !modeInfoNode.querySelector('.vim-mode-toggle')) {
                        updatingStatus = true;
                        // Wrap the text node inside modeInfoNode with a clickable span
                        var wrapper = document.createElement('span');
                        wrapper.className = 'vim-mode-toggle';
                        wrapper.textContent = modeInfoNode.textContent;
                        modeInfoNode.textContent = '';
                        modeInfoNode.appendChild(wrapper);
                        updatingStatus = false;
                    }
                }
            }

            // Ensure command-line input gets focus (with retries for WKWebView)
            var input = statusEl.querySelector('input[type="text"]');
            if (input && document.activeElement !== input) {
                // Multiple focus attempts with increasing delays to handle
                // WKWebView's focus timing quirks
                input.focus();
                setTimeout(function() { if (document.activeElement !== input) input.focus(); }, 0);
                setTimeout(function() { if (document.activeElement !== input) input.focus(); }, 50);
                setTimeout(function() { if (document.activeElement !== input) input.focus(); }, 150);
            }
        }
    });
    observer.observe(statusEl, { childList: true, characterData: true, subtree: true });

    // Click handler for vim mode toggle in status bar
    statusEl.addEventListener('click', function(e) {
        var toggle = e.target.closest('.vim-mode-toggle');
        if (!toggle) return;
        if (isInsertMode()) {
            switchToNormalMode();
        } else {
            switchToInsertMode();
        }
    });

    // Register ex commands and mappings once on the global Vim singleton
    var vimCommandsRegistered = false;
    function registerVimCommands() {
        if (vimCommandsRegistered) return;
        vimCommandsRegistered = true;

        var Vim = MonacoVim.VimMode.Vim;

        // :w — save and close
        Vim.defineEx('write', 'w', function() {
            saveAndClose();
        });

        // :q — close only if no unsaved changes
        Vim.defineEx('quit', 'q', function(cm, params) {
            if (params && params.argString === '!') {
                closeWithoutSaving();
            } else if (hasUnsavedChanges()) {
                flashStatus('E37: No write since last change (add ! to override)');
            } else {
                closeWithoutSaving();
            }
        });

        // :wq — save and close
        Vim.defineEx('wquit', 'wq', function() {
            saveAndClose();
        });

        // :x — save and close (only writes if changed, like vim)
        Vim.defineEx('x', 'x', function() {
            if (hasUnsavedChanges()) {
                saveAndClose();
            } else {
                closeWithoutSaving();
            }
        });

        // jk to exit insert mode
        Vim.map('jk', '<Esc>', 'insert');

        // Esc in normal mode to save and close.
        // Define a custom action and map it properly — mapCommand with
        // an empty type string silently does nothing.
        Vim.defineAction('saveAndClose', function() {
            saveAndClose();
        });
        Vim.mapCommand('<Esc>', 'action', 'saveAndClose', {}, { context: 'normal' });
    }

    function enableVim() {
        if (vimModeInstance) {
            vimModeInstance.dispose();
            vimModeInstance = null;
        }

        if (typeof MonacoVim !== 'undefined' && MonacoVim.initVimMode) {
            vimModeInstance = MonacoVim.initVimMode(editor, statusEl);
            registerVimCommands();
        }
        updateHints();
    }

    function disableVim() {
        if (vimModeInstance) {
            vimModeInstance.dispose();
            vimModeInstance = null;
        }
        statusEl.textContent = '';
        updateHints();
    }

    // Public API called from Swift
    window.setContent = function(text, language, isVimEnabled) {
        if (!editor) {
            setTimeout(function() { window.setContent(text, language, isVimEnabled); }, 100);
            return;
        }
        var model = editor.getModel();
        monaco.editor.setModelLanguage(model, language);
        editor.setValue(text);
        originalContent = text;
        vimEnabled = isVimEnabled;
        if (vimEnabled) {
            enableVim();
        } else {
            disableVim();
        }
        editor.focus();
    };

    window.getContent = function() {
        return editor ? editor.getValue() : '';
    };

    updateHints();
})();
</script>
</body>
</html>
