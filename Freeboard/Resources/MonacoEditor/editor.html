<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<link rel="stylesheet" type="text/css" href="vs/editor/editor.main.css">
<style>
    html, body {
        margin: 0;
        padding: 0;
        width: 100%;
        height: 100%;
        overflow: hidden;
        background: #0a0a0a;
    }
    #editor-container {
        width: 100%;
        height: calc(100% - 22px);
    }
    #status-bar {
        position: fixed;
        bottom: 0;
        left: 0;
        right: 0;
        height: 22px;
        background: #1e1e1e;
        font-family: Menlo, monospace;
        font-size: 11px;
        line-height: 22px;
        padding: 0 8px;
        z-index: 1000;
        border-top: 1px solid #333;
        display: flex;
        justify-content: space-between;
        align-items: center;
    }
    #vim-status {
        color: #d4d4d4;
        flex-shrink: 0;
    }
    #editor-hints {
        color: #00c030;
        opacity: 0.5;
        white-space: nowrap;
    }
    #editor-hints .key {
        color: #00ff40;
        opacity: 1;
    }
</style>
</head>
<body>
<div id="editor-container"></div>
<div id="status-bar">
    <div id="vim-status"></div>
    <div id="editor-hints"></div>
</div>

<script src="vs/loader.js"></script>
<script src="vs/editor/editor.main.nls.js"></script>
<script src="vs/editor/editor.main.js"></script>
<!-- Load monaco-vim with AMD hidden so it uses global assignment path -->
<script>var __define = define; define = undefined;</script>
<script src="monaco-vim.js"></script>
<script>define = __define;</script>
<script>
(function() {
    var editor = null;
    var vimEnabled = false;
    var vimModeInstance = null;
    var originalContent = '';
    var statusEl = document.getElementById('vim-status');
    var hintsEl = document.getElementById('editor-hints');
    var editorContainerEl = document.getElementById('editor-container');

    function postMessage(msg) {
        if (window.webkit && window.webkit.messageHandlers && window.webkit.messageHandlers.editorBridge) {
            window.webkit.messageHandlers.editorBridge.postMessage(msg);
        }
    }

    function updateHints() {
        if (!vimEnabled) {
            hintsEl.innerHTML = '<span class="key">Esc</span> save+close';
            return;
        }
        var statusText = statusEl.textContent || '';
        if (statusText.indexOf('INSERT') !== -1 || statusText.indexOf('REPLACE') !== -1) {
            hintsEl.innerHTML = '<span class="key">jk</span> normal mode&nbsp;&nbsp;<span class="key">:x</span> save+close';
        } else {
            hintsEl.innerHTML = '<span class="key">:x</span> save+close&nbsp;&nbsp;<span class="key">i</span> insert mode';
        }
    }

    function hasUnsavedChanges() {
        return editor ? editor.getValue() !== originalContent : false;
    }

    function saveAndClose() {
        if (!editor) return;
        postMessage({ type: 'save', content: editor.getValue() });
    }

    function closeWithoutSaving() {
        postMessage({ type: 'close' });
    }

    function flashStatus(msg) {
        var prevHtml = hintsEl.innerHTML;
        hintsEl.innerHTML = '<span style="color:#ff6060;opacity:1">' + msg + '</span>';
        setTimeout(function() {
            if (hintsEl.textContent === msg) {
                hintsEl.innerHTML = prevHtml;
            }
        }, 2000);
    }

    require.config({ paths: { vs: 'vs' } });

    function initEditor() {
        if (typeof monaco === 'undefined') {
            setTimeout(initEditor, 100);
            return;
        }

        monaco.editor.defineTheme('freeboard-dark', {
            base: 'vs-dark',
            inherit: true,
            rules: [],
            colors: {
                'editor.background': '#0a0a0a',
                'editor.foreground': '#d4d4d4',
                'editorCursor.foreground': '#00ff40',
                'editor.selectionBackground': '#003a0d88',
                'editor.lineHighlightBackground': '#0d1a0d44'
            }
        });

        editor = monaco.editor.create(document.getElementById('editor-container'), {
            value: '',
            language: 'plaintext',
            theme: 'freeboard-dark',
            lineNumbers: 'off',
            minimap: { enabled: false },
            wordWrap: 'on',
            scrollBeyondLastLine: false,
            fontSize: 14,
            fontFamily: 'Menlo, monospace',
            renderLineHighlight: 'none',
            overviewRulerBorder: false,
            overviewRulerLanes: 0,
            hideCursorInOverviewRuler: true,
            scrollbar: {
                verticalScrollbarSize: 8,
                horizontalScrollbarSize: 8
            },
            padding: { top: 8, bottom: 8 },
            automaticLayout: true,
            contextmenu: false,
            tabSize: 2
        });

        // Non-vim Esc handling: save and close
        editor.addCommand(monaco.KeyCode.Escape, function() {
            if (!vimEnabled) {
                saveAndClose();
            }
        });

        // Don't focus here — only focus when setContent is called
        postMessage({ type: 'editorReady' });
    }

    require(['vs/editor/editor.main'], function() {
        initEditor();
    }, function(err) {
        initEditor();
    });

    // Watch vim status changes to update hints
    var observer = new MutationObserver(function() {
        updateHints();
    });
    observer.observe(statusEl, { childList: true, characterData: true, subtree: true });

    // Register ex commands and mappings once on the global Vim singleton
    var vimCommandsRegistered = false;
    function registerVimCommands() {
        if (vimCommandsRegistered) return;
        vimCommandsRegistered = true;

        var Vim = MonacoVim.VimMode.Vim;

        // :w — save and close
        Vim.defineEx('write', 'w', function() {
            saveAndClose();
        });

        // :q — close only if no unsaved changes
        Vim.defineEx('quit', 'q', function(cm, params) {
            if (params && params.argString === '!') {
                closeWithoutSaving();
            } else if (hasUnsavedChanges()) {
                flashStatus('E37: No write since last change (add ! to override)');
            } else {
                closeWithoutSaving();
            }
        });

        // :wq — save and close
        Vim.defineEx('wquit', 'wq', function() {
            saveAndClose();
        });

        // :x — save and close (only writes if changed, like vim)
        Vim.defineEx('x', 'x', function() {
            if (hasUnsavedChanges()) {
                saveAndClose();
            } else {
                closeWithoutSaving();
            }
        });

        // jk to exit insert mode
        Vim.map('jk', '<Esc>', 'insert');

        // Esc in normal mode to save and close
        Vim.mapCommand('<Esc>', '', '', function() {
            saveAndClose();
        }, { context: 'normal' });
    }

    function enableVim() {
        if (vimModeInstance) {
            vimModeInstance.dispose();
            vimModeInstance = null;
        }

        if (typeof MonacoVim !== 'undefined' && MonacoVim.initVimMode) {
            vimModeInstance = MonacoVim.initVimMode(editor, statusEl);
            registerVimCommands();
        }
        updateHints();
    }

    function disableVim() {
        if (vimModeInstance) {
            vimModeInstance.dispose();
            vimModeInstance = null;
        }
        statusEl.textContent = '';
        updateHints();
    }

    // Public API called from Swift
    window.setContent = function(text, language, isVimEnabled) {
        if (!editor) {
            setTimeout(function() { window.setContent(text, language, isVimEnabled); }, 100);
            return;
        }
        var model = editor.getModel();
        monaco.editor.setModelLanguage(model, language);
        editor.setValue(text);
        originalContent = text;
        vimEnabled = isVimEnabled;
        if (vimEnabled) {
            enableVim();
        } else {
            disableVim();
        }
        editor.focus();
    };

    window.getContent = function() {
        return editor ? editor.getValue() : '';
    };

    updateHints();
})();
</script>
</body>
</html>
